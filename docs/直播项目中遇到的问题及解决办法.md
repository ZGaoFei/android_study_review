#### 问题一（架构问题）：

> 播放器封装为单例模式，导致在直播页打开另一个直播页后出现概率性拉取不到流的问题

#### 原因：
> 因为是单例模式，所有整个app都持有一个播放器对象，在打开新直播页面时，由于在onCreate中创建的播放器
但是在上一个关闭的页面中的onDestroy中会把播放器对象销毁，导致刚创建好的播放器被销毁了
概率性的原因是，在onCreate中有一个接口调用，在接口调用成功后会初始化播放器并播放，因为接口请求成功
和上个页面onDestroy调用的时机不确定，导致了概率性
生命周期调用：新页面的onCreate -> onStart -> onResume 然后上个页面的 onStop -> onDestroy

#### 解决：
	1、给创建添加延时，在延迟一定时间后，让创建播放器在销毁之后
	2、引用计数法，每打开一个播放页面，在创建播放器的时候引用计数加1，在页面的onDestroy中引用计数减1，当计数为0的时候才会去真正的销毁播放器实例
	
	这个问题是因为使用了同一个播放器导致的，并不是整个APP都持有一个播放器的问题
	可以给单个Activity创建单个播放器对象，这样当前activity销毁的只是当前activity对应的播放器

----

#### 问题二：

> 集成腾讯云实时音视频问题

    1、腾讯不支持RGBA模式
    2、镜像问题和图像旋转180问题
    3、旁路推流问题
    4、合流问题
    5、音视频采集问题

#### 解决：

    1、使用texture + eglcontext方式
    2、腾讯云api来提供镜像和旋转
    3、旁路推流可以使用腾讯云的旁路推流或者使用自己的推流
    4、合流交给腾讯云服务器处理
    5、音视频的采集可以使用腾讯云来采集，也可以使用自己采集然后交给腾讯云进行上行

----

#### 问题三（细节问题）：

> 升级声网SDK时，从2.9.2升级到3.3.2时，连麦时对方拉不到视频流

#### 原因：
> 在声网SDK的3.x以上版本中，对byte array方式的视频上行加了判断，即在视频上行时，先判断byte array的长度与
视频的with * height * 4进行对比，当不等于时，则只是输出log，并不会进行上行操作，而直播中是通过
ByteBuffer.allocateDirect(mOutImageWidth * mOutImageHeight * 4)的方式进行初始化缓存大小，然后通过ByteBuffer.array()
获取byte array进行上行。但是ByteBuffer.allocateDirect(mOutImageWidth * mOutImageHeight * 4)在初始化缓存长度的时候会
进行cap + 7的操作，导致最后生成的array数组大于with * height * 4

#### 解决：

    1、使用ByteBuffer.allocate()的方式，会使数组的偏移量为0，生成的array的长度是一致的
    2、在使用ByteBuffer.allocateDirect(width * height * 4 - 7)，这样在初始化的时候+7，正好是width * height * 4
    3、声网提供一个放宽上传条件的版本
    为什么是width * height * 4，因为RGBA正好是每个像素占32位，4个byte

----

#### 问题四：
>升级声网SDK后，发现连麦成功后，断开连麦时，用户端视频会卡住

#### 原因：
>在修改另一个重新加载的bug时，引入的，仅仅是因为一行代码（prepare=false）

----

#### 问题五：

> 腾讯云连麦PK时，主播端的音频和视频不同步，观众端没有问题

#### 原因：
> 因为视频的采集是交由我们自己来处理，然后将视频的每一帧数据交给腾讯云SDK进行上行，而音频则全权交给腾讯云SDK来处理上行，
因此导致音频和视频上行时的时间戳不一致

#### 解决：
> 在腾讯云达到视频帧数据的时候 frame.timestamp = 0 ，将时间戳交给腾讯云SDK去设置
或者使用腾讯云SDK中提供的generateCustomPTS 来获取时间戳

----

#### 问题六：
> Android端多人连麦，当有人退出连麦时，在PC端和iOS端观看直播，房间内的连麦人数没变，并且刚才退出的主播画面一直卡顿

#### 原因：

	当有人退出连麦时，会收到回调，但是以前的逻辑判断是，先获取房间用户数，然后将退出房间的用户删除，再次获取用户数，
	然后判断前面和后面的用户数是否相等，如果相等才会去刷新，这块的逻辑有问题，已经删除了用户，用户数肯定会改变，因此判断不成立。

----

#### 问题七：
> 多人连麦时，从iOS端和PC端观看直播，没有背景图

#### 原因：
> 声网和腾讯云在进行多人连麦的时候会要求上传一张背景图，在声网和腾讯云服务器进行合流的时候，会将背景图合并到流中。
在后台配置背景图时，设置的是内网可访问的背景图，导致声网和腾讯云在服务器进行合流的时候加载不了背景图，导致合流后背景图丢失。

----

#### 问题八（设计架构问题，重要）：
> 如何实现一个直播房间功能，开播页、观看页，页面包含各种逻辑如：聊天、消息、动画特效、礼物、游戏等
如何做到每一个页面之间解耦和页面之间通信，如何做到避免单个类内容过多，如何拆分单个功能模块等

#### 回答：

    1、抽取公用部分
        a、消息分发抽取出一个父类Activity，统一处理，然后由子类Activity实现后进行统一分发给其他Fragment和View，
        b、播放页和开播页功能的中间Fragment，具有很多相同的逻辑，将公用部分抽取出一个公共的Fragment
        c、播放页和开播页功能的左右两边的Fragment基本相同，因此只需要定义LeftFragmet和RightFragment即可通用
        d、消息列表模块逻辑单一，并且播放页和开播页同时使用，因此封装成一个View
        e、展示动画特效模块功能单一，并且播放页和开播页同时使用，因此封装成一个Fragment
        f、顶部用户列表模块功能单一，并且播放页和开播页同时使用，因此封装成一个Fragment或者View
        g、底部操作模块功能单一，并且播放页和开播页同时使用，因此封装成一个View
    
    2、单一职责原则（将复杂页面功能进行划分模块，对应单个模块进行实现，模块之间实现通信）
        a、消息列表模块
        b、展示动画特效模块
        c、顶部用户列表模块
        d、底部操作模块
        e、消息分发模块
    
    3、分层原则（将复杂的页面进行层级划分，由下往上进行叠加显示）
        a、播放视图模块居于最底层，其他视图均在此图层上面
        b、全屏、进度条、视频设置位于播放图层上面
        c、PK连麦等位于第三层
        e、用户列表和用户信息和底部操作位于第四层
        f、动画特效位于第五层
        g、对于一些短暂且临时的布局，可以不放在xml文件中，只需要提供一个Container view，在需要显示的时候添加到Container中，
        显示结束后及时销毁
        h、对于短暂显示但是可能会多次显示的布局，也可以不放在xml文件中，也可以放在Container view中显示， 显示完之后可以做缓存处理，
        在下次显示时直接复用，只需要更新view内容即可
        i、对于复用Container view的情况：
            1、可以减少页面布局层级，
            2、降低xml文件中的布局复杂度，
            3、显示完之后及时销毁可以减少内存使用
            注意布局显示的互斥性，避免出现多个布局显示混乱的问题
        备注：根据需要来分配层级效果（包括弹框、横幅、提示消息、游戏视图、礼物弹框、弹幕、页面状态等等）
    
    4、及时销毁
        将一次性展示的部分，显示完之后及时关闭销毁（如打开页面的引导布局、一次性提示布局等）
        View可以使用动态add和remove，Fragment可以使用动态的add和remove
        关闭页面释放资源
    
    5、模块之间通信（由于采用单一职责原则和分层原则，会分为很多单个模块对应于单个View或者Fragment，因此模块间通信比较复杂）
        a、以Activity为主，进行分发给上层Fragment或者View，再由上层Fragment或者View分发给更上层的Fragment或者View，将消息往上分发
        原理：Activity持有它的上层的Fragment或者View的对象，上传Fragment或者View持有它们更上传的Fragment或者View的对象
    
        b、Fragment或者View设置回调，有Activity或者下层Fragment或者View来实现，将消息向下层传递
        原理：上层Fragment或者View在下层实现，在上层Fragment或者View操作时，需要调用下层的实现，因此通过回调来向下层传递
    
        模块间通信采用其他方式：
        a、使用EventBus来通信
        b、Fragment之间通信可以采用ViewModel

----

#### 问题九：
> 礼物动画特效如何实现

#### 解决：

	帧动画、Lottie、webp、MP4
	a、帧动画，素材来源于网络，在进入房间时会自动去下载相关图片素材
	b、Lottie，数据来源于网络，在进入房间时会自动去下载对应的json数据
	c、webp一种图片显示格式
	d、MP4格式，素材来源于网络，在进入房间时去自动下载视频，直接使用播放器来播放一个MP4格式的视频，需要处理透明度问题
	e、svga
	f、libpag腾讯开源的动画框架

----

#### 问题十（经典问题）：
> 声网升级之后，在华为平台打开连麦崩溃
java.lang.IllegalArgumentException: interface com.huawei.multimedia.audiokit.interfaces.IAudioKitCallback is not visible from class loader
not visible from class loader

#### 原因：

	声网升级后，加入了华为的audiokit库，在声网加载IAudioKitCallback类时，使用了反射代理的方式来初始化，
	但是使用的是传入的mContext.getClassLoader()来获取ClassLoader，由于项目中使用了插件化的原因，传入的context实际是BaseApplicationContext，
	因此与IAudioKitCallback对象的ClassLoader不是同一个。
	
	使用Replugin插件化，宿主使用的是RePluginClassLoader继承自PathClassLoader，而开播插件内使用的是PluginDexClassLoader继承自DexClassLoader
	BaseApplicationContext是宿主里面的类，而宿主的类加载器是PathClassLoader

#### 解决：

	将mContext.getClassLoader()替换为IAudioKitCallback.getClassLoader()

----

#### 问题十一（关联问题十）：
>声网升级后，连麦能成功，但是观众在观看连麦时，拉不下来流

#### 原因：
> 因为声网升级后，导致音频回调不会主动触发，因此音频流没有上行，导致观众拉不下来流

#### 解决：

	主动设置需要监听的回调

----

#### 问题十二（关联问题十和十一）：
> 声网在升级后将音频的监听回调从以前的 byte[] 改为了 ByteBuffer 返回，但是在调用 ByteBuffer.array() 时就会出现崩溃

#### 原因：
> 调用 ByteBuffer.array() 时，内部的 byte[] 为空，主动抛出 UnsupportedOperationException 异常，
由于声网将传入的监听对象直接赋值给了 native 层的方法，因此无法知道 ByteBuffer 的具体操作

#### 解决：

	对ByteBuffer的不了解，局限了只使用array()转换为数组的方式（尴尬）
	使用下面的方式去转换成数组
	byte[] buffer = new byte[audioFrame.samples.limit()];
	audioFrame.samples.get(buffer);
	不要使用audioFrame.samples.array()

----

#### 问题十二（优化项，减小包体积）：
> 提取直播基础功能，发现提取出来的包体积很大 

#### 原因：
> 直播基础功能包含了很多的jar包和so库，以及以前的资源文件和用户到的基础库也包含在内，
并且应要求要适配64模式，因此提供了两套so库，导致包体积很大

#### 解决：
    1、去除无用资源文件和对应的xml文件
    2、压缩现有图片资源
    3、去除无用的第三方库
    4、微信只提供了一套CPU架构支持，64位使用的arm64_v8a，32位使用的armeabi_v7a

----

#### 问题十三
> 64位支持的问题

#### 分析：

	在手机上32位的架构可以运行在64位的手机上（向下兼容），但是64的无法运行在32位的手机上，
	因此在发布apk的时候需要考虑是否引入64位架构，如果引入则会增加apk的包大小，但是谷歌要求上传谷歌应用商店的应用必须支持64位架构
	因此需要引入64位架构。但是在发布应用市场时可以上传两个apk，分别为32位和64位架构，
	应用商店会根据下载手机的架构来下发对应的apk文件。这样做的坏处是测试人员需要对两个apk分别进行测试，增加测试成本。
	在官网上传apk时则需要上传包含32和64位架构的包。

----

#### 问题十四
> 一个项目分别打成不同apk问题

#### 分析：
> 通过配置，可以让一个项目打包成不同的apk，同时支持不同的apk主题样式和页面效果，
通过分包的形式，比如：xl_live、xl_bolive、xl_youliao，可以在assets、res、src对应的文件夹下放入对应apk的不同代码和资源

----

#### 问题十五
> 一个项目可以作为一个apk单独存在，也可以作为另一个apk的其中一个插件来加载
	一个项目也可以打包成aar放在另一个apk的包里面

----

#### 问题十六（学习，第一次）

	一个lib依赖其他的lib和aar和jar包，在将这个lib打包成aar供其他项目使用，如何将其他代码打包进这个lib中？
	1、lib本地依赖第三方jar，将lib包打成aar会将本地jar打包进去
	2、lib本地依赖第三方aar，将lib包打成aar不会将本地aar打包进去（需要将lib依赖的aar一并放到项目中进行依赖）
	3、lib依赖第三方远程maven仓库，将lib包打成aar不会将第三方远程maven仓库一并依赖进新的项目中（需要项目一并引入第三方仓库）
	
	三种方式引入
	1、一个是直接以lib方式引入，问题是lib代码更新之后需要同步更新到项目中，比较麻烦，
	如果多个项目同时使用lib，同步更新的代价会增加，因为需要将lib中的代码在每个项目中都复制一遍
	2、打成aar引入，直接打成aar引入，不用考虑代码变化之后还要同步更新到使用的项目中，只需要将aar替换即可
	3、折中的方式，将SDK需要依赖的lib直接以lib的形式导入，因为这部分不会经常变动，将SDK模块以aar的形式导入，
	aar依然依赖其他的lib（待验证）
	
	SDK开发注意事项：
	1、稳定，SDK的崩溃不会引起app的崩溃
	2、接口易用
	3、命名规范统一
	4、尽量不依赖第三方库
	5、SDK包尽量小
	6、兼容性

----

#### 问题十七
> 打包、加固、分渠道：jinkens、乐固、walle

----

#### 问题十八（插件化问题）
> 直播插件中所有的弹框都显示不出来，根据debug的结果是因为在dialog的show方法中出现了异常，报 NotFoundException Resource ID 0x0000

##### 通过回滚代码，发现是leakcanary导致的，无语，应该是由插件化导致的

----

#### 问题十九（经典问题）
> handler.postDelay() 之后在 run() 方法中执行的操作空指针异常

#### 原因：
> 是因为在 run() 方法中执行集合的获取操作，在其他方法中调用了集合的 clear() 和赋值为null的释放操作，释放操作在前，postDelay 在后

#### 解决：

	添加判空操作
	
	handler也可能会导致内存泄漏问题

----

#### 问题二十（网络请求验签）
> 在网络请求时需要将所有参数名和参数值进行排序后，通过MD5加密生成sign，然后传给服务器，用于验签，为什么要使用MD5加密，如何保证数据不会被修改？

#### 分析

    1、MD5属于单向加密，即加密之后无法解密，保证入参不变的情况下，输出唯一
    2、客户端将参数进行排序，这样避免传递过程中参数顺序改变导致MD5加密值改变
    3、验签是为了数据在传输的过程中避免被篡改，如果两端生成的sign不一致，则表示数据被篡改
    4、在将参数进行加密的时候，服务器和客户端会提前定义好一对appid和appkey，只有服务器和客户端知道，将appid和appkey也加入到MD5加密中，
    这样即使请求被拦截，如果不知道appid和appkey也无法生成对应的sign值，这样就可以保证数据sign值的唯一
    5、服务器和客户端在收到数据后会进行验签处理，如果sign的值不一致则直接丢弃并提示异常

----

#### 问题二十一（文件权限问题）
> 项目中有很多使用文件的地方，包括保存文件和读取文件，在使用文件中需要申请存储权限，在合规中有可能会被认为违规使用个人信息

#### 使用场景：

	1、缓存SP数据
		保存一些配置相关的内容
	2、缓存一些文件，如图片、txt、mp4、png等
		远端资源本地化，将服务器资源下载到本地
		本地生成一些缓存文件，如log日志
		拍照、截图、录屏等保存到本地，仅仅用于本项目使用
	3、拍照、截图、录屏等保存到本地，对其他项目可见
	4、读取项目缓存目录下的文件：Android/data/***/
	5、读取手机内存或者其他目录文件，如选择图片、视频等
	6、等
	
	保存位置：
	    0、SP														/data/data/***/shared_prefs/.xml
	    1、Context.getFilesDir() 									/data/user/0/***/files
	    2、Context.getExternalFilesDir() 							/storage/emulated/0/Android/data/***/
	    3、Context.getExternalCacheDir() 							/storage/emulated/0/Android/data/***/cache
	    4、Environment.getExternalStorageDirectory() 				/storage/emulated/0
	    5、Environment.getStorageDirectory() 						/storage
	    6、Environment.getDataDirectory() 							/data
	    7、Environment.getRootDirectory() 							/system
	    8、Environment.getExternalStoragePublicDirectory("cache") 	/storage/emulated/0/cache
	    9、Environment.getDownloadCacheDirectory() 					/data/cache
	
	是否需要申请权限
	    0/1/2/3：不需要
	    4/5/6/7/8/9：需要
	
	项目文件操作建议：
	    1、SP默认存储
	    2、如果是自己项目中缓存的一些文件或者本地生成的一些缓存文件（log日志）建议保存在/storage/emulated/0/Android/data/***/cache
	    3、远端资源本地化，将服务器资源下载到本地文件建议保存在/storage/emulated/0/Android/data/***/
	    4、拍照、截图、录屏等保存到本地，仅仅用于本项目使用建议保存在/storage/emulated/0/Android/data/***/
	    5、拍照、截图、录屏等保存到本地，对其他项目可见建议保存在/storage/emulated/0
	    以上文件访问只有5需要申请存储权限
	    6、读取项目缓存目录下的文件：Android/data/***/，不需要存储权限
	    7、读取手机内存或者其他目录文件，如选择图片、视频等，需要存储权限
	
	    最小化的申请存储权限，在必要的时候去申请
	    将文件操作放在同一个工具类中进行封装，避免重复封装，多次封装可能在后面重构时可能会出现遗漏

----

#### 问题二十二（多人连麦实现）
> 多人连麦Android端实现

#### 分析：

	角色划分：
		主持人：创建多人房的主播，拥有踢所有人和禁言所有人的权限
		主播：加入多人房的主播，拥有自己下麦和禁言自己的权限
		观众：观看者，没有操作权限
	1、主持人端，创建房间，并且自己进行推流（自己直播的流），拉取其他麦位的流
	2、主播端，自己进行推流（自己直播的流），拉取其他麦位的流，可以和主持人端一块实现
	3、观众端，仅仅展示多人房的画面，只需要拉取一路流
	
	推流：主持人和主播需要将自己的流推到服务器，分发给其他端
	拉流：各个端都需要拉取其他端的流来展示
	合流：多人房需要将主持人和主播的流进行合并，最后合并成一路流，给观众端展示
	转推：由第三方实现，将当前主持人或者主播的流由第三方推到指定的服务器（CDN）上
	
	多人房使用的是第三方直播框架（声网、腾讯云）来进行合流和转推
	
	流程：
	1、主持人创建房间成功后，由直播状态变为多人房状态，默认人数为3人，主持人将自己预览的画面设置到指定的麦位上（默认第一个麦位），布局变为多人房布局
	2、当有主播加入多人房时，主持人端会收到消息，进行更新麦位布局，第三方直播框架会回调joined回调，并返回一个renderView来显示远端画面，主持人端将renderView放到对应的位置上去显示当前麦位的画面
	3、主播端加入多人房后，主播由直播状态变为多人房状态，默认人数为3人，主播将自己预览的画面设置到指定的麦位上（加入的对应的麦位上），布局变为多人房布局
	4、当有人加入多人房时，主播端会收到消息，进行更新麦位布局，第三方直播框架会回调joined回调，并返回一个renderView来显示远端画面，主播端将renderView放到对应的位置上去显示当前麦位的画面
	5、主持人踢人或者主播主动下麦时，后面的麦位自动填充前面的麦位
	6、主持人下麦，全部麦位的成员全部变为单播模式
	7、当多人房人数小于等于3人时，只展示3个麦位，可以有空麦位，空麦位显示默认布局
	8、当多人房人数大于3人时，展示对应人数的麦位，每加入一个主播多显示一个麦位，每下麦一个主播隐藏一个麦位
	9、观众端同步展示多人房内容，同7/8
	10、主持人端和主播端麦位展示时，当前麦位的信息布局是贴在麦位上的，即每个麦位的底层是展示直播画面的renderView，上面是显示信息的View，对应着当前主持人或者主播显示自己的直播画面并且拉取其他麦位的直播画面，相当于主持人端和主播端是推一路流，拉取其他麦位的所有的流
	11、观众端麦位展示时，因为只拉取了一路流，所以只有一个画面展示，麦位的展示位置是由合流时指定对应麦位的坐标来确定的，而麦位的信息布局还是贴在上面的，即底层只有一个显示直播画面的renderView，上面分别对应不同的麦位显示多个麦位信息的View
	12、在推流时，需要将多人房内的麦位位置、坐标、视频显示的宽高指定好，第三方会根据设置的麦位位置、坐标在视频显示的宽高区域内进行放置，（这里一定要将视频区域的宽高和各个麦位的位置、坐标对应上，否则会出现在观众端显示画面有空隙或者重叠的情况，进而导致麦位信息的布局无法对应麦位画面位置）第三方会根据观众端设置的视频显示区域将麦位全局显示

----

#### 问题二十三（MAC、IMEI、IMSI、设备序列号）

	MAC：（英语：Media Access Control Address），直译为媒体存取控制位址，也称为局域网地址（LAN Address）
		相关：与WiFi网络有关（WifiManager）
		权限：<uses-permission android:name="android.permission.ACCESS_WIFI_STATE">
		获取：wifi.getConnectionInfo().getMacAddress()
	
	IMEI：国际移动设备识别码（International Mobile Equipment Identity，IMEI），即通常所说的手机序列号、手机“串号”，用于在移动电话网络中识别每一部独立的手机等移动通信设备
		相关：手机SIM卡（TelephoneManager）
		权限：Manifest.permission.READ_PHONE_STATE
		获取：telephonyManager.getImei()、telephonyManager.getDeviceId()
	
	IMSI：国际移动用户识别码（英语：IMSI，International Mobile Subscriber Identity），是用于区分蜂窝网络中不同用户的、在所有蜂窝网络中不重复的识别码。
		相关：蜂窝网络
		权限：Manifest.permission.READ_PHONE_STATE
		获取：telephonyManager.getSubscriberId()
	
	设备序列号：
		相关：
		权限：Manifest.permission.READ_PHONE_STATE
		获取：Secure.ANDROID_ID（Android ID）、Build.getSerial()

----

## 还缺一些优化项

#### 优化一：
> 包体积优化（64位问题）

#### 优化二：
> 播放器优化（播放页 - 小窗播放 - 主播主页 - 播放页，全局一个播放器对象，导致onDestroy的调用在下一个页面的onCreate后，导致播放器被销毁）

#### 优化三：
> OutOfMemoryError问题

#### 分析：
> 主播开播过程中，会有很多的动效和图片展示，在项目中这些动效多以帧动画或者webp或者MP4为主，导致页面加载图片过多，出现内存溢出问题

#### 优化四：

	1、加载完资源之后及时销毁
	2、优化Bitmap

#### 优化五：
> 首页第一次启动缓慢，统计发现差不多需要接近10秒才会显示出画面，分析原因，是开启app时做了很多初始化的操作和接口请求和预加载数据操作
> 导致在首页的请求比较靠后，网络请求的线程池不够用，默认12个，而开启到首页打开共请求了40个左右的接口，导致了延迟

解决：
统计启动时到页面显示后的所有接口请求，对不必要开启app就请求的接口做延迟处理，把首页加载数据的接口放在更前面，更快的显示数据

----

## 项目中牛叉的地方

#### 功能一：
> 连麦功能的封装

#### 实现：
> 抽象出一个接口，来定义需要实现的方法，由具体的子类来实现具体的方法，如声网的实现方式、腾讯云的实现方式、即构的实现方式

#### 好处：
> 在调用的时候使用抽象出的接口，然后根据具体的需要来创建不同的子类，调用方法的时候根据具体实现的子类调用不同的方法。
>符合【依赖倒置原则】

----

#### 功能二：
> 插件、module、apk相结合的方式来构建项目，多项目构建

#### 实现：

    由于项目中使用到了插件化和组件化相结合的方案
    插件化：单一模块功能但是包体积比较大、提供完整的模块功能、包含页面的采用插件化模式
    组件化：单一模块功能包体积比较小、提供基础功能、不包含页面功能的采用组件化module模式
    插件复用：多个app都需要用到直播插件，因此插件化只需要提供一份即可
    组件复用：在一个app中可以使用lib方式引入，另一个app可以采用生成aar的形式依赖
    多项目构建：多个项目使用的是同一套代码，但是主题样式不一样，
                在一个项目的基础上添加对应的其他项目的主题颜色和样式，在构建apk时就可以生成不同的项目，而不需要维护多个项目
    单一插件调试：由于使用插件化，每一个插件就是一个单一的apk，可以进行单独的调试

#### 好处：

    单一功能原则
    复用原则

----

#### 功能三：
> 直播间功能

#### 实现：

    1、提取公共类父类，子类扩展
    2、抽象接口，不同实现
    3、抽离单一功能View，单一功能封装为单一的View

#### 缺点：

    1、所有布局都冗余到了一起
    2、所有逻辑都放在了一个类里，fragment里面或者activity
    3、布局多以回调的方式来与宿主通信，导致fragment实现的类过多
    4、分离的不够彻底，代码冗杂在一块，功能冗杂在一块，布局冗杂在一块

----

#### 功能四：
> 组件通信模块

#### 实现：

    自己实现的组件化通信模块
    1、base library提供注册、保存、分发功能
    2、组件实现具体路由，提供注册入口
    3、宿主调用各个组件的注册入口给base保存
    4、各个组件调用路由由base进行分发

----

#### 功能五：
> 顺序执行和切换线程模块（类似于RxJava的顺序执行和无缝切换线程）

#### 实现：

    1、指定当前方法在UI线程还是子线程执行
    2、UI线程和子线程相互切换
        使用handler来线程间通信，子线程交给线程池
    3、顺序执行
        将所有任务存放在队列里，循环从队列里取任务去执行，执行完之后删除任务
        任务执行完后自动停止，添加任务会触发循环取任务去执行的逻辑

----

## 项目流程问题 

#### 问题一：
> 运营直接给开发提需求，且是口头需求，没有需求文档

----

#### 问题二：
> 各个小组讨论需求时，人员不齐，只是找其中一端的人进行讨论和制定需求，且制定完之后没有进行同步

----

#### 问题三：
> 流程推动缓慢，且整个开发和测试流程不齐全

----

#### 问题四：
> 测试不严谨，测试面覆盖不全，测试机缺少严重且老旧

----

#### 问题五：
> 对项目质量和重量要求太低，质量：流程度，启动速度，卡顿，帧率；重量：包大小，插件大小，引入三方库大小

----

#### 问题六：
> 对问题不够重视，如线上问题

----

#### 问题七：
> 开发在开发其他需求时，会经常被打断加入其他需求

----

#### 问题八：
> 产品不确定发版日期，由开发来决定

----